{-------------------------------------------------------------------------------
 Mapping for major LibC functions in order to be able to link .o regular C files
 compiled with gcc for Win64
 
 Copyright (c) 2003-2011 Matias Vara <matiasvara@yahoo.com>
 All Rights Reserved
-------------------------------------------------------------------------------}

unit Libc;


//------------------------------------------------------------------------------
// Compiler Version Information
//------------------------------------------------------------------------------

{$IFDEF FPC}
  {$MODE DELPHI}
  {$ASMMODE Intel}
  {$DEFINE SUPPORTS_DEFAULTPARAMS}
  {$DEFINE SUPPORTS_DEPRECATED}
  {$DEFINE SUPPORTS_DEPRECATED_WARNINGS}
  {$DEFINE SUPPORTS_ENUMVALUE}
  {$DEFINE SUPPORTS_INT64}
  {$DEFINE SUPPORTS_OVERLOAD}
  {$DEFINE SUPPORTS_VARARGS}
{$ENDIF FPC}

//------------------------------------------------------------------------------
// General Compiler Settings
//------------------------------------------------------------------------------

{$A+}
(* The $A directive controls alignment of fields in record types.

   In the {$A+} state, fields in record types that are declared without the
   packed modifier are aligned. In the {$A-} state, fields in record types
   are never aligned. Record type field alignment is described in the Object
   Pascal Language Guide.

   Regardless of the state of the $A directive, variables and typed constants
   are always aligned for optimal access. In the {$A+} state, execution
   will be faster. *)

{$B-}
(* The $B directive switches between the two different models of code
   generation for the and and or Boolean operators.

   In the {$B+} state, the compiler generates code for complete Boolean
   expression evaluation. This means that every operand of a Boolean
   expression built from the and and or operators is guaranteed to be
   evaluated, even when the result of the entire expression is already known.

   In the {$B-} state, the compiler generates code for short-circuit Boolean
   expression evaluation, which means that evaluation stops as soon as the
   result of the entire expression becomes evident in left to right order
   of evaluation. *)

{$H+}
(* The $H directive controls the meaning of the reserved word string when
   used alone in a type declaration. The generic type string can represent
   either a long, dynamically-allocated string (the fundamental type AnsiString)
   or a short, statically-allocated string (the fundamental type ShortString).

   By default {$H+}, Delphi defines the generic string type to be the long
   AnsiString. All components in the Visual Component Library are compiled
   in this state. If you write components, they should also use long strings,
   as should any code that receives data from VCL string-type properties.

   The {$H-} state is mostly useful for using code from versions of Object
   Pascal that used short strings by default. You can locally override the
   meaning of string-type definitions to ensure generation of short strings.
   You can also change declarations of short string types to string[255] or
   ShortString, which are unambiguous and independent of the $H setting. *)

{$J-}
(* The $J directive controls whether typed constants can be modified or not.
   In the {$J+} state, typed constants can be modified, and are in essence
   initialized variables. In the {$J-} state, typed constants are truly
   constant, and any attempt to modify a typed constant causes the compiler
   to report an error. *)

{$T+}
(* The $T directive controls the types of pointer values generated by the
   @ operator and the compatibility of pointer types.

   In the {$T-} state, the result of the @ operator is always an untyped
   pointer (Pointer) that is compatible with all other pointer types.
   When @ is applied to a variable reference in the {$T+} state, the result
   is a typed pointer that is compatible only with Pointer and with other
   pointers to the type of the variable. *)

{$X+}
(* The $X directive enables or disables Delphi's extended syntax. *)

interface

uses
  SysUtils, Arch;

implementation

type
  C_char = System.AnsiChar;
  C_char_ptr = System.PAnsiChar;
  C_char_ptr_ptr = ^C_char_ptr;
  C_char_ptr_array = array[0..MaxInt div SizeOf(C_char_ptr) - 1] of C_char_ptr;
  C_char_ptr_array_ptr = ^C_char_ptr_array;
  C_double = System.Double;
  C_double_ptr = ^C_double;
  C_float = System.single;
  C_float_ptr = ^C_float;
  C_int = System.Integer;
  C_int_ptr = ^C_int;
  C_long = System.Integer;
  C_long_ptr = ^C_long;
  C_long_int = System.Integer;
  C_long_int_ptr = C_long_int;
  C_short = System.SmallInt;
  C_short_ptr = ^C_short;
  C_short_int = System.SmallInt;
  C_short_int_ptr = ^C_short_int;
  C_signed_int = System.Integer;
  C_signed_int_ptr = ^C_signed_int;
  C_signed_long = System.Integer;
  C_signed_long_ptr = ^C_signed_long;
  C_unsigned = System.Cardinal;
  C_unsigned_ptr = ^C_unsigned;
  C_unsigned_char = System.Byte;
  C_unsigned_char_ptr = ^C_unsigned_char;
  C_unsigned_char_array = array[0..MaxInt div SizeOf(C_unsigned_char) - 1] of C_unsigned_char;
  C_unsigned_char_array_ptr = ^C_unsigned_char_array;
  C_unsigned_int = System.Cardinal;
  C_unsigned_int_ptr = ^C_unsigned_int;
  C_unsigned_long = System.Cardinal;
  C_unsigned_long_ptr = ^C_unsigned_long;
  C_unsigned_short = System.Word;
  C_unsigned_short_ptr = ^C_unsigned_short;

  C_size_t = C_unsigned;

  C_void_ptr = System.Pointer;
  C_void_ptr_ptr = ^C_void_ptr;
  C_wchar_t = System.WideChar;

  C_wint_t = C_wchar_t;


type
  PMalloc = ^TMalloc;
  TMalloc = record
    Size: longint;
  end;

//  C_wchar_t_ptr = System.PWideChar;

type

  C_qsort_compare_func = function(const p1, p2: C_void_ptr): C_int;

type

  C_time_t = C_long;
  C_time_t_ptr = ^C_time_t;
  C__TIME_T = C_time_t;

type

  C_tm = packed record
    tm_sec: C_int;
    tm_min: C_int;
    tm_hour: C_int;
    tm_mday: C_int;
    tm_mon: C_int;
    tm_year: C_int;
    tm_wday: C_int;
    tm_yday: C_int;
    tm_isdst: C_int;
  end;
  C_tm_ptr = ^C_tm;

var
  __turbofloat: C_int = 0;

  {$Z1}

const
  _IS_UPP = $0001;
  _IS_LOW = $0002;
  _IS_DIG = $0004;
  _IS_SP = $0008;
  _IS_PUN = $0010;
  _IS_CTL = $0020;
  _IS_BLK = $0040;
  _IS_HEX = $0080;
  _IS_ALPHA = $0100;

  _IS_ALNUM = _IS_DIG or _IS_ALPHA;
  _IS_GRAPH = _IS_ALNUM or _IS_HEX or _IS_PUN;

type
  TCharTypeArray = array[C_unsigned_char] of C_unsigned_short;

const
  _chartype: TCharTypeArray = (
    _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL,
    _IS_CTL, _IS_SP or _IS_CTL or _IS_BLK, _IS_SP or _IS_CTL, _IS_SP or _IS_CTL, _IS_SP or _IS_CTL, _IS_SP or _IS_CTL, _IS_CTL, _IS_CTL,
    _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL,
    _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL,
    _IS_SP or _IS_BLK, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN,
    _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN,
    _IS_DIG or _IS_HEX, _IS_DIG or _IS_HEX, _IS_DIG or _IS_HEX, _IS_DIG or _IS_HEX, _IS_DIG or _IS_HEX, _IS_DIG or _IS_HEX, _IS_DIG or _IS_HEX, _IS_DIG or _IS_HEX,
    _IS_DIG or _IS_HEX, _IS_DIG or _IS_HEX, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN,
    _IS_PUN, _IS_UPP or _IS_HEX or _IS_ALPHA, _IS_UPP or _IS_HEX or _IS_ALPHA, _IS_UPP or _IS_HEX or _IS_ALPHA, _IS_UPP or _IS_HEX or _IS_ALPHA, _IS_UPP or _IS_HEX or _IS_ALPHA, _IS_UPP or _IS_HEX or _IS_ALPHA, _IS_UPP or _IS_ALPHA,
    _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA,
    _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA,
    _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN,
    _IS_PUN, _IS_LOW or _IS_HEX or _IS_ALPHA, _IS_LOW or _IS_HEX or _IS_ALPHA, _IS_LOW or _IS_HEX or _IS_ALPHA, _IS_LOW or _IS_HEX or _IS_ALPHA, _IS_LOW or _IS_HEX or _IS_ALPHA, _IS_LOW or _IS_HEX or _IS_ALPHA, _IS_LOW or _IS_ALPHA,
    _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA,
    _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA,
    _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN, _IS_CTL,
    _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_SP or _IS_CTL, _IS_CTL, _IS_CTL,
    _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL,
    _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL,
    _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL, _IS_CTL,
    _IS_SP or _IS_BLK, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN,
    _IS_PUN, _IS_PUN, _IS_LOW or _IS_PUN or _IS_ALPHA, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN,
    _IS_PUN, _IS_PUN, _IS_DIG or _IS_PUN, _IS_DIG or _IS_PUN, _IS_PUN, _IS_LOW or _IS_PUN or _IS_ALPHA, _IS_PUN, _IS_PUN,
    _IS_PUN, _IS_DIG or _IS_PUN, _IS_LOW or _IS_PUN or _IS_ALPHA, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN, _IS_PUN,
    _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA,
    _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA,
    _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_PUN,
    _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_UPP or _IS_ALPHA, _IS_LOW or _IS_ALPHA,
    _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA,
    _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA,
    _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_PUN,
    _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA, _IS_LOW or _IS_ALPHA
    );

type
  TCharLowerArray = array[C_unsigned_char] of C_unsigned_char;

const
  _lower: TCharLowerArray = (
    $00, $01, $02, $03, $04, $05, $06, $07, $08, $09, $0A, $0B, $0C, $0D, $0E, $0F,
    $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $1A, $1B, $1C, $1D, $1E, $1F,
    $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $2A, $2B, $2C, $2D, $2E, $2F,
    $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $3A, $3B, $3C, $3D, $3E, $3F,
    $40, $61, $62, $63, $64, $65, $66, $67, $68, $69, $6A, $6B, $6C, $6D, $6E, $6F,
    $70, $71, $72, $73, $74, $75, $76, $77, $78, $79, $7A, $5B, $5C, $5D, $5E, $5F,
    $60, $61, $62, $63, $64, $65, $66, $67, $68, $69, $6A, $6B, $6C, $6D, $6E, $6F,
    $70, $71, $72, $73, $74, $75, $76, $77, $78, $79, $7A, $7B, $7C, $7D, $7E, $7F,
    $80, $81, $82, $83, $84, $85, $86, $87, $88, $89, $8A, $8B, $8C, $8D, $8E, $8F,
    $90, $91, $92, $93, $94, $95, $96, $97, $98, $99, $9A, $9B, $9C, $9D, $9E, $9F,
    $A0, $A1, $A2, $A3, $A4, $A5, $A6, $A7, $A8, $A9, $AA, $AB, $AC, $AD, $AE, $AF,
    $B0, $B1, $B2, $B3, $B4, $B5, $B6, $B7, $B8, $B9, $BA, $BB, $BC, $BD, $BE, $BF,
    $E0, $E1, $E2, $E3, $E4, $E5, $E6, $E7, $E8, $E9, $EA, $EB, $EC, $ED, $EE, $EF,
    $F0, $F1, $F2, $F3, $F4, $F5, $F6, $D7, $F8, $F9, $FA, $FB, $FC, $FD, $FE, $DF,
    $E0, $E1, $E2, $E3, $E4, $E5, $E6, $E7, $E8, $E9, $EA, $EB, $EC, $ED, $EE, $EF,
    $F0, $F1, $F2, $F3, $F4, $F5, $F6, $F7, $F8, $F9, $FA, $FB, $FC, $FD, $FE, $FF
    );

type
  TCharUpperArray = array[C_unsigned_char] of C_unsigned_char;

const
  _upper: TCharUpperArray = (
    $00, $01, $02, $03, $04, $05, $06, $07, $08, $09, $0A, $0B, $0C, $0D, $0E, $0F,
    $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $1A, $1B, $1C, $1D, $1E, $1F,
    $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $2A, $2B, $2C, $2D, $2E, $2F,
    $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $3A, $3B, $3C, $3D, $3E, $3F,
    $40, $41, $42, $43, $44, $45, $46, $47, $48, $49, $4A, $4B, $4C, $4D, $4E, $4F,
    $50, $51, $52, $53, $54, $55, $56, $57, $58, $59, $5A, $5B, $5C, $5D, $5E, $5F,
    $60, $41, $42, $43, $44, $45, $46, $47, $48, $49, $4A, $4B, $4C, $4D, $4E, $4F,
    $50, $51, $52, $53, $54, $55, $56, $57, $58, $59, $5A, $7B, $7C, $7D, $7E, $7F,
    $80, $81, $82, $83, $84, $85, $86, $87, $88, $89, $8A, $8B, $8C, $8D, $8E, $8F,
    $90, $91, $92, $93, $94, $95, $96, $97, $98, $99, $9A, $9B, $9C, $9D, $9E, $9F,
    $A0, $A1, $A2, $A3, $A4, $A5, $A6, $A7, $A8, $A9, $AA, $AB, $AC, $AD, $AE, $AF,
    $B0, $B1, $B2, $B3, $B4, $B5, $B6, $B7, $B8, $B9, $BA, $BB, $BC, $BD, $BE, $BF,
    $C0, $C1, $C2, $C3, $C4, $C5, $C6, $C7, $C8, $C9, $CA, $CB, $CC, $CD, $CE, $CF,
    $D0, $D1, $D2, $D3, $D4, $D5, $D6, $D7, $D8, $D9, $DA, $DB, $DC, $DD, $DE, $DF,
    $C0, $C1, $C2, $C3, $C4, $C5, $C6, $C7, $C8, $C9, $CA, $CB, $CC, $CD, $CE, $CF,
    $D0, $D1, $D2, $D3, $D4, $D5, $D6, $F7, $D8, $D9, $DA, $DB, $DC, $DD, $DE, $FF
    );

procedure _ftol;
asm
  DB $55
  DB $8B, $EC
  DB $8D, $65, $F4
  DB $9B
  DB $D9, $7D, $FC
  DB $9B
  DB $8A, $45, $FD
  DB $81, $4D, $FC, $01, $0C, $00, $00
  DB $D9, $6D, $FC
  DB $DF, $7D, $F4
  DB $88, $45, $FD
  DB $D9, $6D, $FC
  DB $8B, $45, $F4
  DB $8B, $55, $F8
  DB $8B, $E5
  DB $5D
end;

procedure _ftoul;
asm
  DB $83, $C4, $F4
  DB $9B
  DB $D9, $3C, $24
  DB $9B
  DB $8A, $44, $24, $01
  DB $80, $4C, $24, $01, $0C
  DB $D9, $2C, $24
  DB $DF, $7C, $24, $04
  DB $88, $44, $24, $01
  DB $D9, $2C, $24
  DB $8B, $44, $24, $04
  DB $8B, $54, $24, $08
  DB $83, $C4, $0C
end;

procedure _lldiv;
asm
        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        MOV     EBX, [RSP+16]
        MOV     ECX, [RSP+20]
        MOV     ESI, EDX
        MOV     EDI, ECX
        SAR     ESI, 31
        XOR     EAX, ESI
        XOR     EDX, ESI
        SUB     EAX, ESI
        SBB     EDX, ESI
        SAR     EDI, 31
        XOR     ESI, EDI
        XOR     EBX, EDI
        XOR     ECX, EDI
        SUB     EBX, EDI
        SBB     ECX, EDI
        JNZ     @@BigDivisor
        CMP     EDX, EBX
        JB      @@OneDiv
        MOV     ECX, EAX
        MOV     EAX, EDX
        XOR     EDX, EDX
        DIV     EBX
        XCHG    EAX, ECX
@@OneDiv:
        DIV     EBX
        MOV     EDX, ECX
        JMP     @SetSign
@@BigDivisor:
        SUB     ESP, 12
        MOV     [RSP  ], EAX
        MOV     [RSP+4], EBX
        MOV     [RSP+8], EDX
        MOV     EDI, ECX
        SHR     EDX, 1
        RCR     EAX, 1
        ROR     EDI, 1
        RCR     EBX, 1
        BSR     ECX, ECX
        SHRD    EBX, EDI, CL
        SHRD    EAX, EDX, CL
        SHR     EDX, CL
        ROL     EDI, 1
        DIV     EBX
        MOV     EBX, [RSP]
        MOV     ECX, EAX
        IMUL    EDI, EAX
        MUL     DWORD PTR [RSP+4]
        ADD     EDX, EDI
        SUB     EBX, EAX
        MOV     EAX, ECX
        MOV     ECX, [RSP+8]
        SBB     ECX, EDX
        SBB     EAX, 0
        XOR     EDX, EDX
        ADD     ESP, 12
@SetSign:
        XOR     EAX, ESI
        XOR     EDX, ESI
        SUB     EAX, ESI
        SBB     EDX, ESI
@Done:
        POP     EDI
        POP     ESI
        POP     EBX
        RET     8
end;

procedure _llmod;
asm
        push    ebp
        push    ebx
        push    esi
        push    edi
        xor   edi,edi

        mov     ebx,[Rsp+20]
        mov     ecx,[Rsp+24]
        or      ecx,ecx
        jnz     @__llmod@slow_ldiv

        or      edx,edx
        jz      @__llmod@quick_ldiv

        or      ebx,ebx
        jz      @__llmod@quick_ldiv

@__llmod@slow_ldiv:

        or      edx,edx
        jns     @__llmod@onepos
        neg     edx
        neg     eax
        sbb     edx,0
        or      edi,1

@__llmod@onepos:
        or      ecx,ecx
        jns     @__llmod@positive
        neg     ecx
        neg     ebx
        sbb     ecx,0

@__llmod@positive:
        mov     ebp,ecx
        mov     ecx,64
        push    edi

        xor     edi,edi
        xor     esi,esi

@__llmod@xloop:
        shl     eax,1
        rcl     edx,1
        rcl     esi,1
        rcl     edi,1
        cmp     edi,ebp
        jb      @__llmod@nosub
        ja      @__llmod@subtract
        cmp     esi,ebx
        jb      @__llmod@nosub

@__llmod@subtract:
        sub     esi,ebx
        sbb     edi,ebp
        inc     eax

@__llmod@nosub:
        loop    @__llmod@xloop

        mov     eax,esi
        mov     edx,edi

        pop     ebx
        test    ebx,1
        jz      @__llmod@finish
        neg     edx
        neg     eax
        sbb     edx,0

@__llmod@finish:
        pop     edi
        pop     esi
        pop     ebx
        pop     ebp
        ret     8

@__llmod@quick_ldiv:
        div     ebx
        xchg  eax,edx
        xor     edx,edx
        jmp     @__llmod@finish
end;

procedure _llmul;
asm
        push  edx
        push  eax

        mov   eax, [Rsp+16]
        mul   dword ptr [Rsp]
        mov   ecx, eax

        mov   eax, [Rsp+4]
        mul   dword ptr [Rsp+12]
        add   ecx, eax

        mov   eax, [Rsp]
        mul   dword ptr [Rsp+12]
        add   edx, ecx

        pop   ecx
        pop   ecx

        ret     8
end;

procedure _llshl;
asm
        cmp cl, 32
        jl  @__llshl@below32
        cmp cl, 64
        jl  @__llshl@below64
        xor edx, edx
        xor eax, eax
        ret

@__llshl@below64:
        mov edx, eax
        shl edx, cl
        xor eax, eax
        ret

@__llshl@below32:
        shld  edx, eax, cl
        shl eax, cl
        ret
end;

procedure _llshr;
asm
        cmp cl, 32
        jl  @__llshr@below32
        cmp cl, 64
        jl  @__llshr@below64
        sar edx, 1fh
        mov eax,edx
        ret

@__llshr@below64:
        mov eax, edx
        cdq
        sar eax,cl
        ret

@__llshr@below32:
        shrd  eax, edx, cl
        sar edx, cl
        ret
end;

procedure _lludiv;
asm
        push    ebp
        push    ebx
        push    esi
        push    edi

        mov     ebx,[Rsp+20]
        mov     ecx,[Rsp+24]

        or      ecx,ecx
        jnz     @__lludiv@slow_ldiv

        or      edx,edx
        jz      @__lludiv@quick_ldiv

        or      ebx,ebx
        jz      @__lludiv@quick_ldiv

@__lludiv@slow_ldiv:
        mov     ebp,ecx
        mov     ecx,64
        xor     edi,edi
        xor     esi,esi

@__lludiv@xloop:
        shl     eax,1
        rcl     edx,1
        rcl     esi,1
        rcl     edi,1
        cmp     edi,ebp
        jb      @__lludiv@nosub
        ja      @__lludiv@subtract
        cmp     esi,ebx
        jb      @__lludiv@nosub

@__lludiv@subtract:
        sub     esi,ebx
        sbb     edi,ebp
        inc     eax

@__lludiv@nosub:
        loop    @__lludiv@xloop

@__lludiv@finish:
        pop     edi
        pop     esi
        pop     ebx
        pop     ebp
        ret     8

@__lludiv@quick_ldiv:
        div     ebx
        xor     edx,edx
        jmp     @__lludiv@finish
end;

procedure _llumod;
asm
        push    ebp
        push    ebx
        push    esi
        push    edi

        mov     ebx,[Rsp+20]
        mov     ecx,[Rsp+24]
        or      ecx,ecx
        jnz     @__llumod@slow_ldiv

        or      edx,edx
        jz      @__llumod@quick_ldiv

        or      ebx,ebx
        jz      @__llumod@quick_ldiv

@__llumod@slow_ldiv:
        mov     ebp,ecx
        mov     ecx,64
        xor     edi,edi
        xor     esi,esi

@__llumod@xloop:
        shl     eax,1
        rcl     edx,1
        rcl     esi,1
        rcl     edi,1
        cmp     edi,ebp
        jb      @__llumod@nosub
        ja      @__llumod@subtract
        cmp     esi,ebx
        jb      @__llumod@nosub

@__llumod@subtract:
        sub     esi,ebx
        sbb     edi,ebp
        inc     eax

@__llumod@nosub:
        loop    @__llumod@xloop

        mov     eax,esi
        mov     edx,edi

@__llumod@finish:
        pop     edi
        pop     esi
        pop     ebx
        pop     ebp
        ret     8

@__llumod@quick_ldiv:
        div     ebx
        xchg  eax,edx
        xor     edx,edx
        jmp     @__llumod@finish
end;

function _ltolower(Ch: C_int): C_int;[public , alias : '__imp__tolower'];
begin
  Result := Ch;
  if C_unsigned_int(Result) <= High(_lower) then
    Result := _lower[Result];
end;

function _ltoupper(Ch: C_int): C_int;[public , alias :'__imp__toupper'];
begin
  Result := Ch;
  if C_unsigned_int(Result) <= High(_upper) then
    Result := _upper[Result];
end;

function atol(const nPtr: C_char_ptr): C_long;
var
  c: Byte;
  p: PByte;
  is_neg: Boolean;
begin
  Result := 0;
  p := PByte(nPtr);
  if Assigned(p) then
    begin
      c := p^;
      while _chartype[c] and _IS_SP <> 0 do
        begin
          Inc(p);
          c := p^;
        end;

      if (c = Ord('+')) or (c = Ord('-')) then
        begin
          is_neg := c = Ord('-');
          Inc(p);
          c := p^;
        end
      else
        is_neg := False;

      while (c >= Ord('0')) and (c <= Ord('9')) do
        begin
          Result := Result * 10 + c - Ord('0');
          Inc(p);
          c := p^;
        end;

      if is_neg then
        Result := -Result;
    end;
end;

function malloc(Size: C_size_t): C_void_ptr;[public , alias : '_malloc'];
var
  MemMgr: System.{$IFDEF COMPILER_10_UP}TMemoryManagerEx{$ELSE}TMemoryManager{$ENDIF};
  Pblk: PMalloc;
begin
  System.GetMemoryManager(MemMgr);
  // Size of Block + Block of Memory
  Pblk:= MemMgr.GetMem(Size+sizeof(TMalloc));
  if Pblk=nil then
  begin
   result:=nil;
   exit
  end else
  begin
   Pblk.Size:=Size;
   // Return a free block
   result:=Pblk + sizeof(TMalloc);
  end;
end;

function calloc(NElem: Cardinal; elsize: Cardinal): Pointer;
begin
  result:=malloc(NElem * elsize);
  if result <> nil then
  FillChar(Result^, NElem * elsize, 0);
end;

procedure Free(Block: C_void_ptr);[public , alias :'_free'];
var
  MemMgr: System.{$IFDEF COMPILER_10_UP}TMemoryManagerEx{$ELSE}TMemoryManager{$ENDIF};
  Pblk: PMalloc;
begin
  if Block <> nil then
  begin
    System.GetMemoryManager(MemMgr);
    Pblk := Block - sizeof(TMalloc);
    MemMgr.FreeMemSize(PBlk,Pblk.size+sizeof(TMalloc));
  end;
end;

function isalpha(c: C_int): C_int;
begin
  if C_unsigned(c) <= High(_chartype) then
    Result := _chartype[c] and _IS_ALPHA
  else
    Result := 0;
end;

function isalnum(c: C_int): C_int;[public , alias :'__imp__isalnum'];
begin
  if C_unsigned(c) <= High(_chartype) then
    Result := _chartype[c] and _IS_ALNUM
  else
    Result := 0;
end;

function isdigit(c: C_int): C_int;
begin
  if C_unsigned(c) <= High(_chartype) then
    Result := _chartype[c] and _IS_DIG
  else
    Result := 0;
end;

function isspace(c: C_int): C_int;[public , alias : '__imp__isspace'];
begin
  if C_unsigned(c) <= High(_chartype) then
    Result := _chartype[c] and _IS_SP
  else
    Result := 0;
end;

function isxdigit(c: C_int): C_int;[public , alias :'__imp__isxdigit'];
begin
  if C_unsigned(c) <= High(_chartype) then
    Result := _chartype[c] and _IS_HEX
  else
    Result := 0;
end;

var
  LocalTimeVar: C_tm = (tm_isdst: 0);
  LocalTimeToro : TNow;

function localtime(const Clock: C_time_t_ptr): C_tm_ptr;[public , alias : '_localtime'];
begin
  Now(@LocalTimeToro);
  LocalTimeVar.tm_year := LocalTimeToro.Year - 1900;
  LocalTimeVar.tm_mon := LocalTimeToro.Month - 1;
 // LocalTimeVar.tm_wday := LocalTimeToro.wDayOfWeek;
  LocalTimeVar.tm_mday := LocalTimeToro.Day;
  LocalTimeVar.tm_hour := LocalTimeToro.Hour;
  LocalTimeVar.tm_min := LocalTimeToro.Min;
  LocalTimeVar.tm_sec := LocalTimeToro.Sec;
  Result := @LocalTimeVar;
end;

function MemCmp(const s1: C_void_ptr; const s2: C_void_ptr; n: C_size_t): C_int;[public , alias :'_memcmp'];
label
  Success;
type
  TByte4 = packed record
    b0, b1, b2, b3: Byte;
  end;
  PByte4 = ^TByte4;
var
  p1, p2: PByte4;
  b1, b2: Byte;
begin
  p1 := s1;
  p2 := s2;
  if p1 = p2 then
    goto Success;
  repeat
    if n = 0 then
      goto Success;
    b1 := p1.b0; b2 := p2.b0;
    if b1 <> b2 then
      Break;
    Dec(n);
    if n = 0 then
      goto Success;
    b1 := p1.b1; b2 := p2.b1;
    if b1 <> b2 then
      Break;
    Dec(n);
    if n = 0 then
      goto Success;
    b1 := p1.b2; b2 := p2.b2;
    if b1 <> b2 then
      Break;
    Dec(n);
    if n = 0 then
      goto Success;
    b1 := p1.b3; b2 := p2.b3;
    if b1 <> b2 then
      Break;
    Inc(p1);
    Inc(p2);
    Dec(n);
  until False;
  Result := b1 - b2;
  Exit;

  Success:
  Result := 0;
end;

function memcpy(Dest: C_void_ptr; const Src: C_void_ptr; n: C_size_t): C_void_ptr;[public , alias :'_memcpy'];
begin
  Result := Dest;
  Move(Src^, Result^, n);
end;

function memmove(Dest: C_void_ptr; Src: C_void_ptr; const n: C_size_t): C_void_ptr;[public , alias :'_memmove'];
begin
  Result := Dest;
  Move(Src^, Result^, n);
end;

function memset(const s: C_void_ptr; const c: C_int; const n: C_size_t): C_void_ptr;[public , alias :'_memset'];
begin
  Result := s;
  FillChar(Result^, n, c);
end;

procedure QSort(baseP: C_void_ptr; NElem: C_size_t; Width: C_size_t; const comparF: C_qsort_compare_func);

  procedure Exchange(p1, p2: C_void_ptr);
  type
    T01 = Byte;
    P01 = ^T01;
    T04 = Cardinal;
    P04 = ^T04;
  var
    Temp1: T01;
    Temp4: T04;
    i: Integer;
  begin
    i := Width;
    while i >= 4 do
    begin
      Temp4 := P04(p1)^;
      P04(p1)^ := P04(p2)^;
      P04(p2)^ := Temp4;
      Inc(p1, 4);
      Inc(p2, 4);
      Dec(i, 4);
    end;
    while i > 0 do
    begin
      Temp1 := P01(p1)^;
      P01(p1)^ := P01(p2)^;
      P01(p2)^ := Temp1;
      Inc(p1);
      Inc(p2);
      Dec(i);
    end;
  end;

  procedure qSortHelp(pivotP: PAnsiChar; NElem: Cardinal);
  label
    TailRecursion, qBreak;
  var
    leftP, rightP, pivotEnd, pivotTemp, leftTemp: PAnsiChar;
    lNum: Cardinal;
    retval: Integer;
  begin
    TailRecursion:
    if NElem <= 2 then
    begin
      if NElem = 2 then
      begin
        rightP := pivotP + Width;
        if comparF(pivotP, rightP) > 0 then
          Exchange(pivotP, rightP);
      end;
      Exit;
    end;
    rightP := (NElem - 1) * Width + pivotP;
    leftP := (NElem shr 1) * Width + pivotP;

    if comparF(leftP, rightP) > 0 then
      Exchange(leftP, rightP);
    if comparF(leftP, pivotP) > 0 then
      Exchange(leftP, pivotP)
    else if comparF(pivotP, rightP) > 0 then
      Exchange(pivotP, rightP);
    if NElem = 3 then
    begin
      Exchange(pivotP, leftP);
      Exit;
    end;
    leftP := pivotP + Width;
    pivotEnd := leftP;
    repeat
      retval := comparF(leftP, pivotP);
      while retval <= 0 do
      begin
        if retval = 0 then
        begin
          Exchange(leftP, pivotEnd);
          Inc(pivotEnd, Width);
        end;
        if (leftP < rightP) then
          Inc(leftP, Width)
        else
          goto qBreak;
        retval := comparF(leftP, pivotP);
      end;
      while leftP < rightP do
      begin
        retval := comparF(pivotP, rightP);
        if retval < 0 then
          Dec(rightP, Width)
        else
        begin
          Exchange(leftP, rightP);
          if retval <> 0 then
          begin
            Inc(leftP, Width);
            Dec(rightP, Width);
          end;
          Break;
        end;
      end;
    until not (leftP < rightP);

    qBreak:
    if comparF(leftP, pivotP) <= 0 then
      Inc(leftP, Width);
    leftTemp := leftP - Width;
    pivotTemp := pivotP;
    while (pivotTemp < pivotEnd) and (leftTemp >= pivotEnd) do
    begin
      Exchange(pivotTemp, leftTemp);
      Inc(pivotTemp, Width);
      Dec(leftTemp, Width);
    end;
    lNum := (Cardinal(leftP) - Cardinal(pivotEnd)) div Width;
    NElem := ((NElem * Width + Cardinal(pivotP)) - Cardinal(leftP)) div Width;
    if NElem < lNum then
    begin
      qSortHelp(leftP, NElem);
      NElem := lNum;
    end else
    begin
      qSortHelp(pivotP, lNum);
      pivotP := leftP;
    end;
    goto TailRecursion;
  end;

begin
  if Width <> 0 then
    qSortHelp(baseP, NElem);
end;

function realloc(Block: C_void_ptr; Size: C_size_t): C_void_ptr;[public , alias :'_realloc'];
var
  MemMgr: System.{$IFDEF COMPILER_10_UP}TMemoryManagerEx{$ELSE}TMemoryManager{$ENDIF};
  Pblk: PMalloc;
begin
  if Block <> nil then
  begin
    Pblk := Block - sizeof(TMalloc);
    System.GetMemoryManager(MemMgr);
    if Size > 0 then
    begin
      Pblk := MemMgr.ReallocMem(Pblk,Pblk.Size+sizeof(TMalloc),Size+sizeof(TMalloc));
      Pblk.Size := Size;
      Result := Pblk + sizeof(TMalloc);
    end else begin
      MemMgr.FreeMemSize(Pblk,Pblk.size+sizeof(TMalloc));
      Result := nil;
    end;
  end else
   Result := malloc(Size);
end;

function strcmp(s1: C_char_ptr; s2: C_char_ptr): C_int;[public , alias : '_strcmp'];
var
  c1, c2: C_int;
begin
  if s1 = s2 then
    Result := 0
  else
  begin
    if Assigned(s1) then
    begin
      if Assigned(s2) then
      begin
        repeat
          c1 := Ord(s1[0]); c2 := Ord(s2[0]);
          if (c1 = c2) and (c1 <> 0) then
          begin
            c1 := Ord(s1[1]); c2 := Ord(s2[1]);
            if (c1 = c2) and (c1 <> 0) then
            begin
              c1 := Ord(s1[2]); c2 := Ord(s2[2]);
              if (c1 = c2) and (c1 <> 0) then
              begin
                c1 := Ord(s1[3]); c2 := Ord(s2[3]);
                if (c1 = c2) and (c1 <> 0) then
                begin
                  Inc(s1, 4); Inc(s2, 4);
                  Continue;
                end;
              end;
            end;
          end;
          Break;
        until False;
        Result := c1 - c2;
      end else
      begin
        Result := 1
      end
    end else
    begin
      Result := -1;
    end;
  end;
end;

function StrLen(const s: C_char_ptr): C_size_t;[public , alias : '_strlen'];
asm
  cmp   dword [rax], 0
  je    @@0
  cmp   dword [rax+1], 0
  je    @@1
  cmp   dword [rax+2], 0
  je    @@2
  cmp   dword [rax+3], 0
  je    @@3
  push  rax
  and   rax, -4
@@Loop:
  add   rax, 4
  mov   rdx, [rax]
  lea   rcx, [rdx-$01010101]
  not   rdx
  and   rdx, rcx
  and   rdx, $80808080
  jz    @@Loop
@@SetResult:
  pop   rcx
  bsf   rdx, rdx
  shr   rdx, 3
  add   rax, rdx
  sub   rax, rcx
  ret
@@0:
  xor   rax, rax
  ret
@@1:
  mov   rax, 1
  ret
@@2:
  mov   rax, 2
  ret
@@3:
  mov   rax, 3
end;

function StrLComp(Str1, Str2 : PChar; L: SizeInt): SizeInt;
var
 counter: SizeInt;
 c1, c2: char;
begin
  counter := 0;
  if L = 0 then
  begin
    StrLComp := 0;
    Exit;
  end;
  repeat
    c1 := str1[counter];
    c2 := str2[counter];
    if (c1 = #0) or (c2 = #0) then break;
    Inc(counter);
  until (c1 <> c2) or (counter >= L);
  StrLComp := ord(c1) - ord(c2);
end;

Function StrLCopy(Dest,Source: PChar; MaxLen: SizeInt): PChar;
var
  counter: SizeInt;
begin
  counter := 0;
  { To be compatible with BP, on a null string, put two nulls }
  if Source[0] = #0 then
  begin
   Dest[0]:=Source[0];
   Inc(counter);
  end;
  while (Source[counter] <> #0)  and (counter < MaxLen) do
  begin
    Dest[counter] := char(Source[counter]);
    Inc(counter);
  end;
  Dest[counter] := #0; // terminate the string
  StrLCopy := Dest;
end;

function strncmp(const s1: C_char_ptr; s2: C_char_ptr; const MaxLen: C_size_t): C_int;[public , alias : '_strncmp'];
begin
  Result := StrLComp(s1, s2, MaxLen);
end;

function strncpy(Dest: C_char_ptr; const Src: C_char_ptr; const MaxLen: C_size_t): C_char_ptr;
begin
  Result := Dest;
  StrLCopy(Result, Src, MaxLen);
end;




//
// This functions still wasn't implemented
//
//
//

procedure GetVersionEx;[public , alias :'__imp__GetVersionExA'];
begin


end;


procedure atoi;[public , alias : '_atoi'];
begin
end;


procedure InitializeCriticalSection;[public , alias :'__imp__InitializeCriticalSection'];
begin
end;

procedure DeleteCriticalSection;[public , alias :'__imp__DeleteCriticalSection'];
begin
end;

procedure EnterCriticalSection;[public , alias :'__imp__EnterCriticalSection'];
begin
end;


procedure LeaveCriticalSection;[public , alias :'__imp__LeaveCriticalSection'];
begin
end;


procedure InterlockedIncrement;[public , alias :'__InterlockedIncrement'];
begin
end;



procedure Sleep;[public , alias :'__imp__Sleep'];
begin
end;



procedure GetCurrentThreadId;[public , alias :'__imp__GetCurrentThreadId'];
begin
end;

procedure MultiByteToWideChar;[public , alias :'__imp__MultiByteToWideChar'];
begin
end;


procedure WideCharToMultiByte;[public , alias :'__imp__WideCharToMultiByte'];
begin
end;

procedure AreFileApisANSI;[public , alias :'__imp__AreFileApisANSI'];
begin
end;


procedure CloseHandle;[public , alias :'__imp__CloseHandle'];
begin
end;

procedure SetFilePointer;[public , alias :'__imp__SetFilePointer'];
begin
end;

procedure GetLastError;[public , alias :'__imp__GetLastError'];
begin
end;

procedure ReadFile;[public , alias :'__imp__ReadFile'];
begin
end;

procedure WriteFile;[public , alias :'__imp__WriteFile'];
begin
end;

procedure SetEndOfFile;[public , alias :'__imp__SetEndOfFile'];
begin
end;

procedure FlushFileBuffers;[public , alias :'__imp__FlushFileBuffers'];
begin
end;


procedure GetFileSize;[public , alias :'__imp__GetFileSize'];
begin
end;


procedure LockFileEx;[public , alias :'__imp__LockFileEx'];
begin
end;

procedure LockFile;[public , alias :'__imp__LockFile'];
begin
end;


procedure UnlockFile;[public , alias :'__imp__UnlockFile'];
begin
end;

procedure CreateFileW;[public , alias :'__imp__CreateFileW'];
begin
end;

procedure CreateFileA;[public , alias :'__imp__CreateFileA'];
begin
end;


procedure DeleteFileW;[public , alias :'__imp__DeleteFileW'];
begin
end;

procedure DeleteFileA;[public , alias :'__imp__DeleteFileA'];
begin
end;


procedure GetFileAttributesW;[public , alias :'__imp__GetFileAttributesW'];
begin
end;

procedure GetFileAttributesA;[public , alias :'__imp__GetFileAttributesA'];
begin
end;


procedure GetTempPathW;[public , alias :'__imp__GetTempPathW'];
begin
end;

procedure GetTempPathA;[public , alias :'__imp__GetTempPathA'];
begin
end;

procedure GetFullPathNameW;[public , alias :'__imp__GetFullPathNameW'];
begin
end;


procedure GetFullPathNameA;[public , alias :'__imp__GetFullPathNameA'];
begin
end;



procedure LoadLibraryW;[public , alias :'__imp__LoadLibraryW'];
begin
end;

procedure LoadLibraryA;[public , alias :'__imp__LoadLibraryA'];
begin
end;


procedure FormatMessageA;[public , alias :'__imp__FormatMessageA'];
begin
end;



procedure GetProcAddress;[public , alias :'__imp__GetProcAddress'];
begin
end;



procedure FreeLibrary;[public , alias :'__imp__FreeLibrary'];
begin
end;

procedure GetSystemTime;[public , alias :'__imp__GetSystemTime'];
begin
end;

procedure GetCurrentProcessId;[public , alias :'__imp__GetCurrentProcessId'];
begin
end;

procedure GetTickCount;[public , alias :'__imp__GetTickCount'];
begin
end;

procedure QueryPerformanceCounter;[public , alias :'__imp__QueryPerformanceCounter'];
begin
end;


procedure GetSystemTimeAsFileTime;[public , alias :'__imp__GetSystemTimeAsFileTime'];
begin
end;









end.

